<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1v1 Auto Battler with Emojis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Default Light Mode Styles */
            background-color: #f3f4f6;
            color: #333;
        }

        /* Dark Mode Styles */
        body.dark {
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
        }

        .dark .bg-white { background-color: #2d3748 !important; } /* Darker cards */
        .dark .text-gray-800 { color: #e2e8f0 !important; }
        .dark .text-gray-700 { color: #cbd5e0 !important; }
        .dark .text-gray-500 { color: #a0aec0 !important; }
        .dark .border-gray-200 { border-color: #4a5568 !important; }
        .dark .battle-log.bg-emerald-100 { background-color: #4a5568 !important; border-color: #636b77 !important; color: #cbd5e0 !important;}
        .dark .item-selected { border-color: #0d9488; box-shadow: 0 0 0 3px #0d9488;} /* Darker emerald for selected items in dark mode */
        .dark .hp-bar-container { background-color: #4a5568; border-color: #718096; }
        .dark .hp-bar-container::before { background-image: repeating-linear-gradient(to right, transparent, transparent calc(10% - 1px), #718096 calc(10% - 1px), #718096 10%); }


        .hit {
            animation: hitAnim 0.5s ease;
        }

        @keyframes hitAnim {
            0% { transform: translateX(0) scale(1); }
            25% { transform: translateX(-10px) scale(1.02); }
            50% { transform: translateX(10px) scale(1.02); }
            75% { transform: translateX(-10px) scale(1.02); }
            100% { transform: translateX(0) scale(1); }
        }

        /* Style for selected items */
        .item-selected {
            border-color: #10B981; /* Emerald green */
            box-shadow: 0 0 0 3px #10B981; /* Green ring */
        }

        /* Gradient for buttons */
        .btn-gradient-blue { background-image: linear-gradient(to right, #3B82F6, #2563EB); }
        .btn-gradient-blue:hover { background-image: linear-gradient(to right, #2563EB, #1D4ED8); }

        .btn-gradient-emerald { background-image: linear-gradient(to right, #10B981, #059669); }
        .btn-gradient-emerald:hover { background-image: linear-gradient(to right, #059669, #047857); }

        .btn-gradient-gray { background-image: linear-gradient(to right, #6B7280, #4B5563); }
        .btn-gradient-gray:hover { background-image: linear-gradient(to right, #4B5563, #374151); }

        .btn-gradient-yellow { background-image: linear-gradient(to right, #F59E0B, #D97706); }
        .btn-gradient-yellow:hover { background-image: linear-gradient(to right, #D97706, #B45309); }

        .btn-gradient-purple { background-image: linear-gradient(to right, #9333ea, #7e22ce); }
        .btn-gradient-purple:hover { background-image: linear-gradient(to right, #7e22ce, #6b21a8); }


        /* New: Red tint for defeated player profiles */
        .loser-tint {
            filter: brightness(70%) grayscale(50%);
            border-color: #EF4444; /* Red border */
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.7); /* Red glow */
        }

        /* New: Purple tint for poisoned players */
        .poison-tint {
            /* filter: hue-rotate(270deg) saturate(1.5) brightness(0.9); */ /* REMOVED TINT */
            border-color: #8B5CF6; /* Purple border */
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.7); /* Purple glow */
        }

        /* New: White flash for dodges */
        @keyframes dodgeFlashAnim {
            0% { filter: brightness(1) drop-shadow(0 0 0 rgba(255,255,255,0)); }
            50% { filter: brightness(2) drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
            100% { filter: brightness(1) drop-shadow(0 0 0 rgba(255,255,255,0)); }
        }
        .dodge-flash {
            animation: dodgeFlashAnim 0.3s ease-out; /* Quick pop and fade */
        }

        /* New: Blue flash for stun */
        @keyframes stunFlashAnim {
            0% { filter: brightness(1) drop-shadow(0 0 0 rgba(0,191,255,0)); }
            50% { filter: brightness(1.5) drop-shadow(0 0 15px rgba(0,191,255,0.7)); }
            100% { filter: brightness(1) drop-shadow(0 0 0 rgba(0,191,255,0)); }
        }
        .stun-flash {
            animation: stunFlashAnim 0.3s ease-out; /* Quick pop and fade */
        }


        /* Floating text for damage/healing */
        .floating-text {
            position: absolute;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: floatUpFade 2.0s forwards; /* Increased duration */
            z-index: 10;
            white-space: nowrap; /* Prevent text wrapping */
            font-size: 1.8rem; /* Default size */
        }

        .floating-text.damage { color: #dc2626; } /* Red */
        .floating-text.critical {
            color: #f59e0b; /* Orange */
            font-size: 2.5rem; /* Enlarge critical hit numbers */
            animation: floatUpFade 1.5s forwards; /* Slightly faster fade for crits */
        }
        .floating-text.heal { color: #10b981; } /* Green */
        .floating-text.poison { color: #8b5cf6; } /* Purple */
        .floating-text.thorns { color: #6b7280; } /* Gray for thorns/reflect */


        @keyframes floatUpFade {
            0% { transform: translateY(0px) translateX(-50%); opacity: 1; }
            100% { transform: translateY(-90px) translateX(-50%); opacity: 0; } /* Increased float distance */
        }

        /* Stat highlight animations */
        .stat-highlight {
            transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .stat-increase {
            background-color: rgba(16, 185, 129, 0.3); /* Emerald green translucent */
            color: #059669; /* Darker green text */
        }

        .dark .stat-increase {
            background-color: rgba(16, 185, 129, 0.5);
            color: #a7f3d0;
        }

        .stat-decrease {
            background-color: rgba(239, 68, 68, 0.3); /* Red translucent */
            color: #dc2626; /* Darker red text */
        }

        .dark .stat-decrease {
            background-color: rgba(239, 68, 68, 0.5);
            color: #fca5a5;
        }

        /* Modal specific styles */
        .modal-content {
            max-height: 80vh; /* Limit height to prevent overflow on small screens */
            overflow-y: auto; /* Enable scrolling for modal content */
        }
        
        /* HP Bar Styles */
        .hp-bar-container {
            width: 80%;
            height: 14px; /* THINNER HP BAR */
            background-color: #e5e7eb;
            border-radius: 10px;
            border: 1px solid #d1d5db;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        .hp-bar-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: repeating-linear-gradient(to right, transparent, transparent calc(10% - 1px), #d1d5db calc(10% - 1px), #d1d5db 10%);
            z-index: 1;
        }

        .hp-bar-fill {
            height: 100%;
            border-radius: 8px;
            transition: width 0.5s ease-in-out, background-color 0.5s ease-in-out;
            position: relative;
            z-index: 2;
        }

        .hp-high { background-color: #22c55e; } /* Green */
        .hp-mid { background-color: #f59e0b; } /* Amber */
        .hp-low { background-color: #ef4444; } /* Red */
        .hp-poisoned { background-color: #9333ea; } /* Purple-600 */
        .dark .hp-poisoned { background-color: #a855f7; } /* Purple-500 */
        
        /* Toast Notification */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
        }
        #toast.show {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -10px);
        }
        #toast.success { background-color: #22c55e; }
        #toast.error { background-color: #ef4444; }

    </style>
</head>
<body class="selection:bg-blue-200 selection:text-blue-800">

    <div id="fighters" class="flex flex-col md:flex-row justify-center items-stretch w-full max-w-4xl gap-6 my-8">
        <!-- Player 1 -->
        <div id="fighter1" class="fighter flex-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200 flex flex-col items-center transform transition-transform duration-300 relative">
            <h2 id="player1Name" class="text-3xl font-bold mb-4 text-purple-700 dark:text-purple-400 cursor-pointer">Player 1</h2>
            <div class="stats text-xl mb-1">HP: <span id="hp1" class="font-semibold text-red-600"></span>/<span id="maxhp1"></span>
                <span id="reg_visual_1" class="text-green-500 text-sm ml-1"></span>
                <span id="poison_visual_1" class="text-purple-500 text-sm ml-1"></span>
            </div>
            <div class="hp-bar-container">
                <div id="hp-bar-fill-1" class="hp-bar-fill hp-high"></div>
            </div>
            <div class="stats text-xl mt-2 mb-2">Attack: <span id="atk1" class="font-semibold text-gray-800 dark:text-gray-300"></span>
                <span id="crit_visual_1" class="text-orange-500 text-sm ml-1"></span>
            </div>
            <div class="stats text-xl mb-2">Defense: <span id="def1" class="font-semibold text-blue-600"></span>
                <span id="dodge_visual_1" class="text-gray-500 text-sm ml-1"></span>
            </div>
            <div class="stats text-xl mb-2">Speed: <span id="spd1" class="font-semibold text-yellow-600"></span> </div>
            <div class="mt-4 w-full text-center">
                <div class="text-base text-gray-700 dark:text-gray-300">Inventory</div>
                <div id="inv1" class="font-medium text-gray-900 dark:text-gray-200 mt-1 h-12 flex flex-wrap justify-center items-center gap-x-4 gap-y-2"></div>
            </div>
            <div class="flex flex-wrap justify-center gap-2 mt-4">
                <button onclick="randomizeItems(1)" id="randomize1" class="btn-gradient-yellow text-white font-bold py-2 px-4 rounded-full shadow-md transition duration-300 ease-in-out transform hover:scale-105">Randomize Items</button>
                <button onclick="openPresetsModal(1)" id="presets1" class="btn-gradient-purple text-white font-bold py-2 px-4 rounded-full shadow-md transition duration-300 ease-in-out transform hover:scale-105">Presets</button>
            </div>
        </div>

        <!-- Player 2 -->
        <div id="fighter2" class="fighter flex-1 bg-white p-6 rounded-xl shadow-lg border border-gray-200 flex flex-col items-center transform transition-transform duration-300 relative">
            <h2 id="player2Name" class="text-3xl font-bold mb-4 text-green-700 dark:text-green-400 cursor-pointer">Player 2</h2>
            <div class="stats text-xl mb-1">HP: <span id="hp2" class="font-semibold text-red-600"></span>/<span id="maxhp2"></span>
                <span id="reg_visual_2" class="text-green-500 text-sm ml-1"></span>
                <span id="poison_visual_2" class="text-purple-500 text-sm ml-1"></span>
            </div>
            <div class="hp-bar-container">
                <div id="hp-bar-fill-2" class="hp-bar-fill hp-high"></div>
            </div>
            <div class="stats text-xl mt-2 mb-2">Attack: <span id="atk2" class="font-semibold text-gray-800 dark:text-gray-300"></span>
                <span id="crit_visual_2" class="text-orange-500 text-sm ml-1"></span>
            </div>
            <div class="stats text-xl mb-2">Defense: <span id="def2" class="font-semibold text-blue-600"></span>
                <span id="dodge_visual_2" class="text-gray-500 text-sm ml-1"></span>
            </div>
            <div class="stats text-xl mb-2">Speed: <span id="spd2" class="font-semibold text-yellow-600"></span> </div>
            <div class="mt-4 w-full text-center">
                <div class="text-base text-gray-700 dark:text-gray-300">Inventory</div>
                <div id="inv2" class="font-medium text-gray-900 dark:text-gray-200 mt-1 h-12 flex flex-wrap justify-center items-center gap-x-4 gap-y-2"></div>
            </div>
            <div class="flex flex-wrap justify-center gap-2 mt-4">
                <button onclick="randomizeItems(2)" id="randomize2" class="btn-gradient-yellow text-white font-bold py-2 px-4 rounded-full shadow-md transition duration-300 ease-in-out transform hover:scale-105">Randomize Items</button>
                <button onclick="openPresetsModal(2)" id="presets2" class="btn-gradient-purple text-white font-bold py-2 px-4 rounded-full shadow-md transition duration-300 ease-in-out transform hover:scale-105">Presets</button>
            </div>
        </div>
    </div>

    <h3 class="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-4">Choose Items (Up to 4 per player)</h3>

    <!-- Item buttons will be rendered here by JavaScript -->
    <div id="items" class="flex flex-row flex-wrap justify-center gap-6 mb-8 max-w-5xl"></div>

    <div class="flex flex-wrap justify-center gap-4 mb-8">
        <button onclick="startBattle()" id="startButton" class="btn-gradient-blue text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-300">Start Battle</button>
        <button onclick="resetGame()" class="btn-gradient-gray text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-300">Reset Battle</button>
        <button onclick="analyzeBattle()" id="analyzeBattleButton" class="btn-gradient-emerald text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-emerald-300" style="display: none;">Analyze Battle</button>
    </div>

    <!-- Battle Analysis Div -->
    <div id="battleAnalysis" class="battle-log bg-emerald-100 p-4 rounded-xl shadow-lg border border-emerald-200 w-full max-w-3xl h-auto overflow-y-auto text-center text-md mb-6" style="display: none;">
        <p class="text-emerald-700 italic">Battle analysis will appear here...</p>
    </div>

    <div class="battle-log bg-white p-6 rounded-xl shadow-lg border border-gray-200 w-full max-w-3xl h-64 overflow-y-auto text-left text-sm leading-relaxed tracking-wide" id="log">
        <p class="text-gray-500 italic">Battle log will appear here...</p>
    </div>
    
    <div id="toast"></div>

    <!-- Name Change Modal -->
    <div id="nameChangeModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-xl max-w-sm w-full">
            <h3 class="text-xl font-bold mb-4 text-gray-800 dark:text-gray-100">Change Player Name</h3>
            <input type="text" id="newNameInput" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200" placeholder="Enter new name">
            <div class="flex justify-end gap-2">
                <button onclick="hideNameChangeModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-md transition duration-200">Cancel</button>
                <button id="confirmNameChange" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">Save</button>
            </div>
        </div>
    </div>

    <!-- Presets Modal -->
    <div id="presetsModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-xl max-w-3xl w-full modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800 dark:text-gray-100">Choose a Preset Build</h3>
                <button onclick="hidePresetsModal()" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">&times;</button>
            </div>
            <div class="flex gap-2 mb-4">
                <button onclick="openSavePresetModal()" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">Save Current Build</button>
                <button onclick="openLoadPresetModal()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">Load from ID</button>
            </div>
            <h4 class="text-lg font-semibold mt-6 mb-2 text-gray-700 dark:text-gray-300">Default Builds</h4>
            <div id="defaultPresetsList" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 mb-4">
                <!-- Default Preset buttons will be rendered here -->
            </div>
            <h4 class="text-lg font-semibold mt-6 mb-2 text-gray-700 dark:text-gray-300">Shared Builds</h4>
            <div id="sharedPresetsList" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <!-- Shared Preset buttons will be rendered here -->
            </div>
        </div>
    </div>
    
    <!-- Save Preset Modal -->
    <div id="savePresetModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-xl max-w-sm w-full">
            <h3 class="text-xl font-bold mb-4 text-gray-800 dark:text-gray-100">Save Preset</h3>
            <input type="text" id="presetNameInput" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-green-500 bg-white dark:bg-gray-700" placeholder="Enter preset name...">
            <div class="flex justify-end gap-2">
                <button onclick="hideSavePresetModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-md transition duration-200">Cancel</button>
                <button onclick="savePreset()" id="confirmSavePreset" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">Save</button>
            </div>
        </div>
    </div>

    <!-- Load Preset Modal -->
    <div id="loadPresetModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-xl max-w-sm w-full">
            <h3 class="text-xl font-bold mb-4 text-gray-800 dark:text-gray-100">Load Preset from ID</h3>
            <input type="text" id="presetIdInput" class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700" placeholder="Paste preset ID...">
            <div class="flex justify-end gap-2">
                <button onclick="hideLoadPresetModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-md transition duration-200">Cancel</button>
                <button onclick="loadPresetFromId()" id="confirmLoadPreset" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">Load</button>
            </div>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Setup ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        let userId;
        let presetsUnsubscribe = null;

        async function setupFirebase() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                userId = auth.currentUser?.uid || `anon_${crypto.randomUUID()}`;
                console.log("Firebase Auth successful. User ID:", userId);
                
                // Make firebase instances globally available for non-module script
                window.db = db;
                window.auth = auth;
                window.userId = userId;
                window.appId = appId;
                window.collection = collection;
                window.addDoc = addDoc;
                window.onSnapshot = onSnapshot;
                window.query = query;
                window.doc = doc;
                window.getDoc = getDoc;

            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        }
        
        setupFirebase();
        
    </script>

    <script>
        // Initialize dark mode based on device preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.classList.add('dark');
        }

        // Listen for changes in device theme preference (optional, but good for dynamic switching)
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.body.classList.add('dark');
            } else {
                document.body.classList.remove('dark');
            }
        });
        
        const sleep = ms => new Promise(res => setTimeout(res, ms));

        // Define the comprehensive list of items with all their properties
        const itemsList = [
            {emoji: 'âš”ï¸', name: "Steel Blade", atk: 12, def: 5, critChance: 0.10},
            {emoji: 'ðŸ”ª', name: "Armor Piercer", atk: 12, armorPenetration: 0.20},
            {emoji: 'ðŸ—¡ï¸', name: "Jade Scimitar", atk: 10, itemHpBonus: 50, dodgeChance: 0.15},
            {emoji: 'â˜ ï¸', name: "Cursed Rune", atk: 22, defDebuffPerTurn: 4},
            {emoji: 'ðŸ—¡ï¸', name: "Windblade", spd: 6, scaleAtkPerSpd: 0.50},
            {emoji: 'ðŸ”¨', name: "Heavy Hammer", atkBasedOnMaxHp: 0.15, spd: -10},
            {emoji: 'ðŸ©¸', name: "Vampiric Gem", atk: 10, itemHpBonus: -100, lifesteal: 0.40},
            {emoji: 'ðŸ', name: "Poison Dagger", atk: 7, poisonOnHit: true, poisonDmgPerTurn: 2, poisonTurns: 9999},
            {emoji: 'âš¡', name: "Thunder Staff", atk: 10, stunChance: 0.20},
            {emoji: 'ðŸŽ­', name: "Berserker Helm", atk: 5, berserkerBonus: 15, berserkerThreshold: 0.4},
            {emoji: 'ðŸ¥·ðŸ»', name: "Assassin's Cloak", lowHpDamageBonus: 2, lowHpThreshold: 0.4},
            {emoji: 'ðŸŽžï¸', name: "Bladewrap", atk: 10, critChance: 0.05, critDamageBonus: 0.25},
            {emoji: 'âš”ï¸', name: "Dual Daggers", atk: -10, doubleAttackChance: 1},
            {emoji: 'ðŸƒ', name: "Razor Leaves", defDebuffOnHit: 0.05},
            {emoji: 'ðŸ”ª', name: "Hidden Dagger", instakillOnZeroDef: true},
            {emoji: 'âœ¨', name: "Mystic Band", itemHpBonus: 20, critBuffOnCritOrDodge: 0.05},
            {emoji: 'ðŸ€', name: "Lucky Coin", critChance: 0.40},
            {emoji: 'ðŸ›¡ï¸', name: "Buckler", def: 7, spd: 10},
            {emoji: 'ðŸ›¡ï¸', name: "Great Shield", def: 10, itemHpBonus: 50, hpRegenPerTurn: 2},
            {emoji: 'ðŸ¥‡', name: "Immortal Plate", def: 10, atkGainOnDamageTaken: 1},
            {emoji: 'â„ï¸', name: "Snowflake Amulet", hpRegenPerTurn: 5, atkDebuffOnHit: 0.05},
            {emoji: 'ðŸ§Š', name: "Ice Bulwark", defBonusPercent: 0.10, spdDebuffOnHit: 2},
            {emoji: 'âš“', name: "Anchor", def: 20, spd: -8, noDodge: true},
            {emoji: 'ðŸ©¸', name: "Soulblood Ampule", soulbloodThreshold: 20, soulbloodDefGain: 8},
            {emoji: 'ðŸª¨', name: "Stone Skin", damageReduction: 0.20},
            {emoji: 'ðŸŽ¯', name: "Sniper's Bow", def: 10, immuneToThorns: true, immuneToReflect: true},
            {emoji: 'ðŸªž', name: "Mirror Plate", reflectBlockedDamage: 0.50},
            {emoji: 'ðŸŒµ', name: "Thorns Charm", thornsDamage: 6},
            {emoji: 'ðŸ’¨', name: "Smoke Bomb", dodgeChance: 0.30, itemHpBonus: -50},
            {emoji: 'ðŸ‘»', name: "Ghost Shard", spd: 10, dodgeChance: 0.10, armorPenetration: 0.10},
            {emoji: 'ðŸ¦‹', name: "Dance Ribbon", spdGainOnDamageTaken: 8, dodgeChance: 0.10},
            {emoji: 'ðŸ’¨', name: "Gale Cloak", dodgeChance: 0.10, immuneToCrits: true},
            {emoji: 'ðŸ‘¢', name: "Swift Boots", spd: 16, noDodge: true},
            {emoji: 'ðŸ‘Ÿ', name: "Winged Tabis", spdPerTurn: 2},
            {emoji: 'ðŸ”®', name: "Foresight Orb", dodgeBuffPerTurn: 0.02},
            {emoji: 'ðŸ’', name: "Hurricane Ring", spdFromCrit: true},
            {emoji: 'ðŸ§²', name: "Magnet Boots", spdFromDef: true},
            {emoji: 'â¤ï¸', name: "Vitality Pendant", itemHpBonus: 80},
            {emoji: 'ðŸ«€', name: "Dragonscale Heart", maxHpFromAtk: true},
            {emoji: 'ðŸ’‰', name: "Venom Stim", itemHpBonus: 150, selfPoisonOnStart: 10},
            {emoji: 'ðŸ’Ž', name: "Regen Crystal", hpRegenPerTurn: 10},
            {emoji: 'ðŸ’', name: "Ring of Life", doubleRegen: true},
            {emoji: 'ðŸ§š', name: "Fairy Ring", spd: 10, regenFromSpd: true},
            {emoji: 'ðŸ’—', name: "Revival Charm", reviveThreshold: 20, reviveHeal: 150}
        ];

        // Define preset builds
        const buildPresets = [
            { emoji: 'ðŸŒªï¸', name: 'The \'Whirlwind Striker\'', items: ['Windblade', 'Swift Boots', 'Hurricane Ring', 'Bladewrap'] },
            { emoji: 'ðŸ¤º', name: 'The \'Duelist\'', items: ['Steel Blade', 'Dual Daggers', 'Mirror Plate', 'Assassin\'s Cloak'] },
            { emoji: 'ðŸ”¨', name: 'The \'Heavy Hitter\'', items: ['Heavy Hammer', 'Ring of Life', 'Dragonscale Heart', 'Great Shield'] },
            { emoji: 'ðŸ’£', name: 'The \'Overwhelming Offense\'', items: ['Cursed Rune', 'Soulblood Ampule', 'Armor Piercer', 'Bladewrap'] },
            { emoji: 'ðŸ‘»', name: 'The \'Evasive Phantom\'', items: ['Ghost Shard', 'Gale Cloak', 'Dance Ribbon', 'Assassin\'s Cloak'] },
            { emoji: 'ðŸ’Ž', name: 'The \'Crit Monster\'', items: ['Lucky Coin', 'Bladewrap', 'Steel Blade', 'Hurricane Ring'] },
            { emoji: 'ðŸ§±', name: 'The \'Stonewall\'', items: ['Stone Skin', 'Great Shield', 'Immortal Plate', 'Bladewrap'] },
            { emoji: 'ðŸ—¿', name: 'The \'Undying Juggernaut\'', items: ['Great Shield', 'Stone Skin', 'Ring of Life', 'Regen Crystal'] },
            { emoji: 'ðŸ’¥', name: 'The \'Glass Cannon Assassin\'', items: ['Cursed Rune', 'Poison Dagger', 'Armor Piercer', 'Assassin\'s Cloak'] },
            { emoji: 'ðŸ§›', name: 'The \'Vampiric Berserker\'', items: ['Vampiric Gem', 'Berserker Helm', 'Immortal Plate', 'Bladewrap'] },
            { emoji: 'ðŸ›¡ï¸', name: 'The \'Crushing Defender\'', items: ['Anchor', 'Great Shield', 'Armor Piercer', 'Sniper\'s Bow'] },
            { emoji: 'âš¡', name: 'The \'Stormbringer\'', items: ['Thunder Staff', 'Mystic Band', 'Lucky Coin', 'Windblade'] },
            { emoji: 'ðŸ’€', name: 'The \'Revenant\'', items: ['Revival Charm', 'Thorns Charm', 'Mirror Plate', 'Berserker Helm'] },
            { emoji: 'ðŸƒ', name: 'The \'Endless Pursuit\'', items: ['Foresight Orb', 'Winged Tabis', 'Fairy Ring', 'Buckler'] },
            { emoji: 'ðŸ’¢', name: 'The \'Retribution Guardian\'', items: ['Thorns Charm', 'Regen Crystal', 'Ring of Life', 'Stone Skin'] },
            { emoji: 'ðŸŒ€', name: 'The \'Disruptor\'', items: ['Snowflake Amulet', 'Razor Leaves', 'Poison Dagger', 'Thunder Staff'] },
            { emoji: 'ðŸŽ¯', name: 'The \'Ghost Hunter\'', items: ['Ghost Shard', 'Ice Bulwark', 'Armor Piercer', 'Sniper\'s Bow'] },
            { emoji: 'ðŸ¤–', name: 'The \'Immovable Annihilator\'', items: ['Anchor', 'Great Shield', 'Sniper\'s Bow', 'Regen Crystal'] },
            { emoji: 'ðŸ’€', name: 'The \'Executioner\'', items: ['Hidden Dagger', 'Armor Piercer', 'Razor Leaves', 'Ghost Shard'] },
            { emoji: 'ðŸ§²', name: 'The \'Magnetic Wall\'', items: ['Magnet Boots', 'Anchor', 'Great Shield', 'Immortal Plate'] },
            { emoji: 'â˜£ï¸', name: 'The \'Poison Gambler\'', items: ['Venom Stim', 'Ring of Life', 'Vampiric Gem', 'Stone Skin'] },
            { emoji: 'ðŸ’ƒ', name: 'The \'Untouchable Fencer\'', items: ['Jade Scimitar', 'Gale Cloak', 'Lucky Coin', 'Bladewrap'] },
            { emoji: 'ðŸ’¥', name: 'The \'Thorns God\'', items: ['Thorns Charm', 'Mirror Plate', 'Immortal Plate', 'Regen Crystal'] },
            { emoji: 'ðŸ’¨', name: 'The \'Speed Demon\'', items: ['Windblade', 'Swift Boots', 'Fairy Ring', 'Hurricane Ring'] }
        ];


        // Default item properties for player initialization to avoid undefined checks
        const defaultItemProperties = {
            atk: 0, def: 0, itemHpBonus: 0, spd: 0, critChance: 0, lifesteal: 0, poisonChance: 0,
            poisonDmgPerTurn: 0, poisonTurns: 0, stunChance: 0, reflectDamage: 0,
            dodgeChance: 0, hpRegenPerTurn: 0, healOnStart: 0, thornsDamage: 0,
            armorPenetration: 0, damageReduction: 0, doubleAttackChance: 0, scaleAtkPerSpd: 0,
            berserkerBonus: 0, berserkerThreshold: 0,
            noDodge: false, requiresSpdForDoubleAttack: false, doubleAttackSpdThreshold: 0,
            negativeDef: 0, poisonOnHit: false, atkGainOnDamageTaken: 0,
            spdGainOnDamageTaken: 0,
            spdPerTurn: 0,
            defDebuffPerTurn: 0, soulbloodThreshold: 0, soulbloodDefGain: 0, dodgeBuffPerTurn: 0,
            critChanceFromRegen: false, defDebuffOnHit: 0, atkDebuffOnHit: 0, reviveThreshold: 0,
            reviveHeal: 0, spdFromCrit: false, critDamageBonus: 0, lowHpDamageBonus: 0, lowHpThreshold: 0,
            maxHpFromAtk: false, atkBasedOnMaxHp: 0, noDodgeAttack: false,
            regenMultiplierOnCrit: 0,
            regenOnCritOrDodge: 0,
            critBuffOnCritOrDodge: 0,
            regenPerCurrentHpPercent: 0,
            immuneToThorns: false, immuneToReflect: false, immuneToCrits: false,
            defBonusPercent: 0, spdDebuffOnHit: 0,
            reflectBlockedDamage: 0,
            regenPerMaxHpPercent: 0,
            hpBonusFromSpd: 0,
            doubleRegen: false,
            regenFromSpd: false,
            instakillOnZeroDef: false,
            spdFromDef: false,
            selfPoisonOnStart: 0
        };

        let p1, p2, battleP1, battleP2;
        let battleInterval;
        const MAX_ITEMS_PER_PLAYER = 4;
        const TURN_LIMIT = 50;
        let turnCounter = 0;
        let p1Name = "Player 1";
        let p2Name = "Player 2";
        let fullBattleLogContent = "";
        let currentPlayerToRename = null; // Used for name change modal
        let currentPlayerForPreset = null; // Used for presets modal
        let presetsUnsubscribe = null;


        // Archetype definitions for emoji display
        const archetypes = [
            { name: 'reviver', emoji: 'ðŸ©¹', scoreFn: p => p.reviveThreshold > 0 ? 100: 0},
            { name: 'hpScaler', emoji: 'ðŸ“ˆ', scoreFn: p => p.atkBasedOnMaxHp * 100 },
            { name: 'berserker', emoji: 'ðŸ‘¹', scoreFn: p => p.berserkerBonus * 5 + p.atkGainOnDamageTaken * 15+ p.spdGainOnDamageTaken * 10 },
            { name: 'swiftStriker', emoji: 'âš¡', scoreFn: p => p.doubleAttackChance * 70 + (p.requiresSpdForDoubleAttack? 30:0) + (p.spdFromCrit? 50: 0) + p.spd * 0.8},
            { name: 'poisonMaster', emoji: 'ðŸ¤¢', scoreFn: p => (p.poisonOnHit? 80: 0) + p.poisonChance * 60 + p.poisonDmgPerTurn * 15 + p.selfPoisonOnStart * 2 },
            { name: 'thorns', emoji: 'ðŸŒµ', scoreFn: p => p.thornsDamage * 8 + p.reflectDamage * 50 },
            { name: 'mage', emoji: 'ðŸ§™', scoreFn: p => p.stunChance * 70 + p.defDebuffPerTurn * 10 + p.atkDebuffOnHit* 30 + p.defDebuffOnHit* 30 + p.spdDebuffOnHit * 20},
            { name: 'ninja', emoji: 'ðŸ¥·', scoreFn: p => p.dodgeChance * 70 + p.spd * 1.2 + p.spdGainOnDamageTaken * 5 + p.dodgeBuffPerTurn * 50 - (p.noDodge? 20:0) },
            { name: 'vampire', emoji: 'ðŸ©¸', scoreFn: p => p.lifesteal * 80 + p.hpRegenPerTurn * 3 + p.healOnStart * 0.6 + (p.maxHpFromAtk ? 50 : 0) + (p.regenMultiplierOnCrit > 0 ? 30 : 0) + (p.regenOnCritOrDodge > 0 ? 30 : 0) + (p.regenPerCurrentHpPercent* 100) },
            { name: 'tank', emoji: 'ðŸ›¡ï¸', scoreFn: p => p.def* 1.5 + p.maxHp * 0.25 + p.negativeDef * -1 + p.damageReduction * 60+ p.atkGainOnDamageTaken * 8 + p.soulbloodDefGain * 10 + p.defBonusPercent * 50 },
            { name: 'fencer', emoji: 'ðŸ¤º', scoreFn: p => p.atk * 1.5 + p.critChance * 50 + p.critDamageBonus * 20 + p.scaleAtkPerSpd * 10+ (p.noDodgeAttack? 25:0)}
        ];

        // Stat color mapping for item descriptions
        const statColorMap = {
            'ATK': 'text-red-400', 'DEF': 'text-blue-400', 'HP': 'text-green-400', 'SPD': 'text-yellow-300',
            'CRIT': 'text-orange-400', 'Crit DMG': 'text-orange-400', 'Lifesteal': 'text-purple-400',
            'Poison on Attack': 'text-violet-400', 'Poison Chance': 'text-violet-400', 'Poison Dmg': 'text-violet-400',
            'Stun Chance': 'text-cyan-400', 'Reflect': 'text-pink-400', 'DODGE': 'text-gray-400', 'REG': 'text-green-400',
            'HEAL.Start': 'text-green-400', 'THNS': 'text-amber-400', 'PEN': 'text-indigo-400', 'DR': 'text-emerald-400',
            'DA': 'text-teal-400', 'ATK/SPD': 'text-rose-400', 'SPD Dmg': 'text-rose-400',
            'No DODGE': 'text-red-400', 'DA if SPD': 'text-teal-400', 'ATK/Dmg Taken': 'text-red-400',
            'SPD on DODGE': 'text-lime-400',
            'SPD/Turn': 'text-yellow-500',
            'DEF/Turn': 'text-sky-400', 'DEF if >Dmg': 'text-blue-400',
            'DODGE/Turn': 'text-yellow-300', 'CRIT%=REG': 'text-orange-400', 'DEF/Hit': 'text-purple-400',
            'ATK/Hit': 'text-sky-400', 'Heal HP if <HP': 'text-pink-300', 'SPD from CRIT %': 'text-yellow-300',
            'DMG <40%HP': 'text-rose-400', 'MAX HP=ATK': 'text-green-400', 'ATK%=MAX HP': 'text-red-400',
            'No DODGE Attack': 'text-red-400', 'REG x CRIT': 'text-green-400', 'REG/Current HP': 'text-green-400',
            'REG on Crit/Dodge': 'text-green-400',
            'CRIT BUFF': 'text-orange-300',
            'Immune to Thorns/Reflect': 'text-emerald-400', 'Immune to Crits': 'text-emerald-400',
            'DEF %': 'text-blue-400', 'SPD Debuff': 'text-yellow-300',
            'Reflect Blocked': 'text-pink-400', 'REG/Max HP': 'text-green-400', 'HP from SPD': 'text-green-400',
            'x2 REG': 'text-green-400', 'REG equal to SPD': 'text-green-400', 'Instakill 0-DEF': 'text-red-500',
            'SPD equal to DEF': 'text-yellow-300', 'Start with 10 Poison': 'text-violet-400'
        };

        // Helper to get color class for stats
        function getStatColorClass(abbr) {
            return statColorMap[abbr] || 'text-white';
        }

        // Helper for floating text
        function showFloatingText(parentId, value, typeClass) {
            const parent = document.getElementById(parentId);
            if (!parent) return;

            const textEl = document.createElement('div');
            textEl.classList.add('floating-text', typeClass);

            let displayValue;
            if (typeClass === 'heal') {
                displayValue = `+${Math.abs(value)} ðŸ’š`;
            } else if (typeClass === 'critical') {
                displayValue = `-${Math.abs(value)}! ðŸ’”`;
            } else if (typeClass === 'thorns') {
                displayValue = `-${Math.abs(value)} ðŸ’”`;
            } else { // 'damage', 'poison'
                displayValue = `-${Math.abs(value)} ðŸ’”`;
            }
            textEl.innerText = displayValue;

            const existingTexts = parent.querySelectorAll('.floating-text');
            const verticalOffset = existingTexts.length * 25;
            const horizontalOffset = (Math.random() - 0.5) * 40;

            textEl.style.left = `calc(50% + ${horizontalOffset}px)`;
            textEl.style.bottom = `calc(50% + ${verticalOffset}px)`;
            textEl.style.transform = 'translateX(-50%)';

            parent.appendChild(textEl);

            textEl.addEventListener('animationend', () => {
                textEl.remove();
            });
        }

        // Helper for stat highlighting
        function highlightStat(statElementId, type) {
            const statEl = document.getElementById(statElementId);
            if (!statEl) return;
            statEl.classList.add('stat-highlight', `stat-${type}`);
            setTimeout(() => {
                statEl.classList.remove('stat-highlight', `stat-${type}`);
            }, 600);
        }

        // Initialize or reset player stats
        function initializePlayers() {
            const basePlayerStats = {
                baseHp: 150, baseAtk: 10, baseDef: 5, baseSpd: 0,
                inv: [],
                poisoned: [],
                stunnedTurns: 0,
                hasRevived: false,
                currentHp: 150,
                maxHp: 150,
                atk: 0, def: 0, spd: 0,
                ...JSON.parse(JSON.stringify(defaultItemProperties))
            };
            p1 = JSON.parse(JSON.stringify(basePlayerStats));
            p2 = JSON.parse(JSON.stringify(basePlayerStats));
        }

        // Calculate and return combined stats from base and inventory
        function getCombinedStats(player) {
            let combined = {...defaultItemProperties};
            combined.atk = player.baseAtk;
            combined.def = player.baseDef;
            combined.spd = player.baseSpd;
            combined.maxHp = player.baseHp;

            player.inv.forEach(item => {
                for (const key in item) {
                    if (item.hasOwnProperty(key) && !['name', 'emoji'].includes(key)) {
                        const value = item[key];
                        if (typeof value === 'boolean') {
                            combined[key] = combined[key] || value;
                        } else if (typeof value === 'number') {
                            if (key === 'itemHpBonus') {
                                combined.maxHp += value;
                            } else if (['poisonChance', 'poisonDmgPerTurn', 'poisonTurns', 'stunChance',
                                      'reflectDamage', 'thornsDamage', 'armorPenetration',
                                      'damageReduction', 'doubleAttackChance', 'berserkerBonus', 'berserkerThreshold',
                                      'soulbloodThreshold', 'soulbloodDefGain',
                                      'reviveThreshold', 'reviveHeal', 'atkBasedOnMaxHp', 
                                      'regenMultiplierOnCrit', 'spdDebuffOnHit',
                                      'reflectBlockedDamage', 'regenPerMaxHpPercent', 'hpBonusFromSpd',
                                      'selfPoisonOnStart', 'lowHpDamageBonus', 'lowHpThreshold'].includes(key)) {
                                combined[key] = Math.max(combined[key], value);
                            } else if (key === 'regenOnCritOrDodge' || key === 'critBuffOnCritOrDodge') {
                                combined[key] = Math.max(combined[key], value);
                            } else {
                                combined[key] += value;
                            }
                        }
                    }
                }
            });
            return combined;
        }

        // Update UI elements with current player stats and emojis
        function updateStats(player, num, isBattlePhase = false) {
            const oldMaxHp = player.maxHp;
            const combined = getCombinedStats(player);
            
            // Apply all item properties to the player object
            for(const key in combined) {
                if (combined.hasOwnProperty(key)) {
                    player[key] = combined[key];
                }
            }
            
            // Apply HP bonus from speed
            if (player.hpBonusFromSpd > 0) {
                player.maxHp += Math.round(player.spd * player.hpBonusFromSpd);
            }

            // Adjust current HP based on max HP changes, only pre-battle
            if (!isBattlePhase) {
                const maxHpDifference = player.maxHp - oldMaxHp;
                if (maxHpDifference !== 0) {
                    player.currentHp += maxHpDifference;
                }
                player.currentHp = Math.min(player.maxHp, player.currentHp);
                if (player.currentHp < 0) player.currentHp = 1; // Prevent negative HP from item removals
            }

            // Only calculate current combat stats from base stats if it's NOT the battle phase.
            if (!isBattlePhase) {
                player.currentAtk = player.atk;
                player.currentDef = player.def * (1 + player.defBonusPercent);
                player.currentSpd = player.spd;
                player.currentCritChance = player.critChance;
                player.currentDodgeChance = player.dodgeChance;

                if (player.spdFromDef) {
                    player.currentSpd += player.currentDef;
                }
                if (player.spdFromCrit) {
                    player.currentSpd += player.currentCritChance * 100;
                }
                if (player.atkBasedOnMaxHp > 0) {
                    player.currentAtk += player.maxHp * player.atkBasedOnMaxHp;
                }
                player.currentAtk += player.currentSpd * player.scaleAtkPerSpd;

                // Apply Dragonscale Heart after all other attack calculations
                if (player.maxHpFromAtk) {
                    player.maxHp += Math.round(player.currentAtk);
                }
            }

            document.getElementById(`hp${num}`).innerText = Math.round(player.currentHp);
            document.getElementById(`maxhp${num}`).innerText = player.maxHp;
            document.getElementById(`atk${num}`).innerText = Math.round(player.currentAtk);
            document.getElementById(`def${num}`).innerText = Math.round(player.currentDef);
            document.getElementById(`spd${num}`).innerText = Math.round(player.currentSpd);
            document.getElementById(`inv${num}`).innerHTML = player.inv.map(i => `<span class="inline-block">${i.emoji} ${i.name}</span>`).join('') || '<span class="text-gray-500 italic">Empty</span>';

            const playerEmoji = determinePlayerEmoji(player);
            document.getElementById(`player${num}Name`).innerHTML = `${(num === 1 ? p1Name : p2Name)} ${playerEmoji}`;

            let effectiveRegenAmount = player.hpRegenPerTurn;
            if (player.regenFromSpd) {
                effectiveRegenAmount += player.currentSpd;
            }
            if (player.regenPerCurrentHpPercent > 0) {
                effectiveRegenAmount += Math.round(player.currentHp * player.regenPerCurrentHpPercent);
            }
            if (player.regenPerMaxHpPercent > 0) {
                effectiveRegenAmount += Math.round(player.maxHp * player.regenPerMaxHpPercent);
            }
            if (player.doubleRegen) {
                effectiveRegenAmount *= 2;
            }
            document.getElementById(`reg_visual_${num}`).innerText = effectiveRegenAmount > 0 ? `REG: +${Math.round(effectiveRegenAmount)}` : '';
            document.getElementById(`poison_visual_${num}`).innerText = player.poisoned?.length > 0 ? `POISON: ${player.poisoned.length}` : '';
            
            const fighterElement = document.getElementById(`fighter${num}`);
            if (player.poisoned?.length > 0) {
                fighterElement.classList.add('poison-tint');
            } else {
                fighterElement.classList.remove('poison-tint');
            }
            
            document.getElementById(`crit_visual_${num}`).innerText = player.currentCritChance > 0 ? `CRIT: ${(player.currentCritChance * 100).toFixed(0)}%` : '';
            document.getElementById(`dodge_visual_${num}`).innerText = player.currentDodgeChance > 0 ? `DODGE: ${(player.currentDodgeChance * 100).toFixed(0)}%` : '';

            // Update HP Bar
            const hpPercent = (player.currentHp / player.maxHp) * 100;
            const hpBarFill = document.getElementById(`hp-bar-fill-${num}`);
            hpBarFill.style.width = `${hpPercent}%`;
            hpBarFill.classList.remove('hp-high', 'hp-mid', 'hp-low', 'hp-poisoned');

            if (player.poisoned?.length > 0) {
                hpBarFill.classList.add('hp-poisoned');
            } else {
                if (hpPercent > 50) {
                    hpBarFill.classList.add('hp-high');
                } else if (hpPercent > 25) {
                    hpBarFill.classList.add('hp-mid');
                } else {
                    hpBarFill.classList.add('hp-low');
                }
            }
        }

        function determinePlayerEmoji(player) {
            let scores = {};
            archetypes.forEach(arc => scores[arc.name] = arc.scoreFn(player));

            let bestArchetype = 'âš”ï¸';
            let maxScore = 0;

            for (const archetype of archetypes) {
                if (scores[archetype.name] > maxScore && scores[archetype.name] > 0) {
                    maxScore = scores[archetype.name];
                    bestArchetype = archetype.emoji;
                }
            }
            return bestArchetype;
        }

        function showNameChangeModal(playerNum) {
            currentPlayerToRename = playerNum;
            const modal = document.getElementById('nameChangeModal');
            const nameInput = document.getElementById('newNameInput');
            nameInput.value = (playerNum === 1 ? p1Name : p2Name);
            modal.classList.remove('hidden');
            nameInput.focus();
        }

        function hideNameChangeModal() {
            document.getElementById('nameChangeModal').classList.add('hidden');
            currentPlayerToRename = null;
        }

        document.getElementById('confirmNameChange').addEventListener('click', () => {
            const newName = document.getElementById('newNameInput').value.trim();
            if (newName) {
                if (currentPlayerToRename === 1) p1Name = newName;
                else if (currentPlayerToRename === 2) p2Name = newName;
                updateStats(currentPlayerToRename === 1 ? p1 : p2, currentPlayerToRename);
            }
            hideNameChangeModal();
        });

        document.getElementById('player1Name').addEventListener('click', () => showNameChangeModal(1));
        document.getElementById('player2Name').addEventListener('click', () => showNameChangeModal(2));

        function openPresetsModal(playerNum) {
            currentPlayerForPreset = playerNum;
            const modal = document.getElementById('presetsModal');
            const defaultPresetsListDiv = document.getElementById('defaultPresetsList');
            defaultPresetsListDiv.innerHTML = '';

            buildPresets.forEach(preset => {
                const btn = document.createElement('button');
                btn.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 text-sm';
                btn.innerHTML = `${preset.emoji} ${preset.name}`;
                btn.onclick = () => applyPreset(currentPlayerForPreset, preset.items);
                defaultPresetsListDiv.appendChild(btn);
            });

            fetchAndDisplaySharedPresets();
            modal.classList.remove('hidden');
        }

        function hidePresetsModal() {
            if (presetsUnsubscribe) {
                presetsUnsubscribe();
                presetsUnsubscribe = null;
            }
            document.getElementById('presetsModal').classList.add('hidden');
            currentPlayerForPreset = null;
        }
        
        function openSavePresetModal() {
            document.getElementById('savePresetModal').classList.remove('hidden');
            document.getElementById('presetNameInput').focus();
        }

        function hideSavePresetModal() {
            document.getElementById('savePresetModal').classList.add('hidden');
        }

        function openLoadPresetModal() {
            document.getElementById('loadPresetModal').classList.remove('hidden');
            document.getElementById('presetIdInput').focus();
        }

        function hideLoadPresetModal() {
            document.getElementById('loadPresetModal').classList.add('hidden');
        }
        
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'show';
            toast.classList.add(type);
            setTimeout(() => {
                toast.className = toast.className.replace('show', '');
            }, 3000);
        }
        
        async function savePreset() {
            if (!window.db) {
                showToast("Database not connected.", "error");
                return;
            }
            const presetName = document.getElementById('presetNameInput').value.trim();
            const player = currentPlayerForPreset === 1 ? p1 : p2;
            const playerName = currentPlayerForPreset === 1 ? p1Name : p2Name;

            if (!presetName) {
                showToast("Please enter a name for your preset.", "error");
                return;
            }
            if (player.inv.length === 0) {
                showToast("Cannot save an empty build.", "error");
                return;
            }

            const presetData = {
                creatorName: playerName,
                presetName: presetName,
                items: player.inv.map(item => item.name)
            };

            try {
                const docRef = await window.addDoc(window.collection(window.db, `/artifacts/${window.appId}/public/data/presets`), presetData);
                showToast(`Preset "${presetName}" saved!`);
                hideSavePresetModal();
            } catch (e) {
                console.error("Error adding document: ", e);
                showToast("Failed to save preset.", "error");
            }
        }

        async function loadPresetFromId() {
            if (!window.db) {
                showToast("Database not connected.", "error");
                return;
            }
            const presetId = document.getElementById('presetIdInput').value.trim();
            if (!presetId) {
                showToast("Please enter a preset ID.", "error");
                return;
            }

            try {
                const docRef = window.doc(window.db, `/artifacts/${window.appId}/public/data/presets`, presetId);
                const docSnap = await window.getDoc(docRef);

                if (docSnap.exists()) {
                    const presetData = docSnap.data();
                    applyPreset(currentPlayerForPreset, presetData.items);
                    showToast(`Loaded preset: ${presetData.presetName}`);
                    hideLoadPresetModal();
                    hidePresetsModal();
                } else {
                    showToast("Preset ID not found.", "error");
                }
            } catch (e) {
                console.error("Error getting document:", e);
                showToast("Failed to load preset.", "error");
            }
        }

        function sharePreset(presetId) {
            const tempInput = document.createElement('input');
            tempInput.value = presetId;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            showToast("Preset ID copied to clipboard!");
        }
        
        function fetchAndDisplaySharedPresets() {
            if (!window.db) {
                console.log("Firestore not ready for fetching presets.");
                return;
            }
            const sharedPresetsListDiv = document.getElementById('sharedPresetsList');
            const presetsCollection = window.collection(window.db, `/artifacts/${window.appId}/public/data/presets`);
            const q = window.query(presetsCollection);

            presetsUnsubscribe = window.onSnapshot(q, (querySnapshot) => {
                sharedPresetsListDiv.innerHTML = '';
                if (querySnapshot.empty) {
                    sharedPresetsListDiv.innerHTML = `<p class="text-gray-500 italic col-span-full">No shared builds yet. Save one to get started!</p>`;
                }
                querySnapshot.forEach((doc) => {
                    const preset = doc.data();
                    const presetId = doc.id;
                    const presetCard = document.createElement('div');
                    presetCard.className = 'bg-gray-200 dark:bg-gray-700 p-3 rounded-lg flex justify-between items-center';
                    
                    const itemEmojis = preset.items.map(itemName => {
                        const item = itemsList.find(i => i.name === itemName);
                        return item ? item.emoji : 'â“';
                    }).join(' ');

                    presetCard.innerHTML = `
                        <div>
                            <p class="font-bold text-gray-800 dark:text-gray-100">${preset.presetName}</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">by ${preset.creatorName}</p>
                            <p class="text-lg mt-1">${itemEmojis}</p>
                        </div>
                        <div class="flex flex-col gap-2">
                            <button class="bg-blue-500 hover:bg-blue-600 text-white text-xs font-bold py-1 px-2 rounded" onclick="applySharedPreset('${presetId}')">Load</button>
                            <button class="bg-gray-500 hover:bg-gray-600 text-white text-xs font-bold py-1 px-2 rounded" onclick="sharePreset('${presetId}')">Share</button>
                        </div>
                    `;
                    sharedPresetsListDiv.appendChild(presetCard);
                });
            });
        }
        
        async function applySharedPreset(presetId) {
             if (!window.db) {
                showToast("Database not connected.", "error");
                return;
            }
            try {
                const docRef = window.doc(window.db, `/artifacts/${window.appId}/public/data/presets`, presetId);
                const docSnap = await window.getDoc(docRef);
                if (docSnap.exists()) {
                    applyPreset(currentPlayerForPreset, docSnap.data().items);
                    hidePresetsModal();
                }
            } catch (e) {
                console.error("Error applying shared preset: ", e);
            }
        }
        
        // Make functions globally accessible
        window.openSavePresetModal = openSavePresetModal;
        window.hideSavePresetModal = hideSavePresetModal;
        window.openLoadPresetModal = openLoadPresetModal;
        window.hideLoadPresetModal = hideLoadPresetModal;
        window.savePreset = savePreset;
        window.loadPresetFromId = loadPresetFromId;
        window.sharePreset = sharePreset;
        window.applySharedPreset = applySharedPreset;
        window.hideNameChangeModal = hideNameChangeModal;
        window.hidePresetsModal = hidePresetsModal;


        function applyPreset(playerNum, presetItemsNames) {
            const player = playerNum === 1 ? p1 : p2;
            const playerName = playerNum === 1 ? p1Name : p2Name;

            player.inv = [];
            presetItemsNames.forEach(itemName => {
                const item = itemsList.find(i => i.name === itemName);
                if (item && player.inv.length < MAX_ITEMS_PER_PLAYER) {
                    player.inv.push(item);
                }
            });

            updateStats(player, playerNum);
            renderItems();
            log(`${playerName} applied a preset build.`);
            hidePresetsModal();
        }

        function renderItems() {
            const container = document.getElementById('items');
            container.innerHTML = '';

            itemsList.forEach((item, index) => {
                const btn = document.createElement('button');
                btn.id = `item-btn-${index}`;

                let itemStatSpans = [];
                if (item.atk) itemStatSpans.push(`<span class="${getStatColorClass('ATK')}"><b>${item.atk > 0 ? '+' : ''}${item.atk}</b>ATK</span>`);
                if (item.def) itemStatSpans.push(`<span class="${getStatColorClass('DEF')}"><b>${item.def > 0 ? '+' : ''}${item.def}</b>DEF</span>`);
                if (item.defBonusPercent) itemStatSpans.push(`<span class="${getStatColorClass('DEF %')}"><b>+${(item.defBonusPercent * 100).toFixed(0)}%</b>DEF</span>`);
                if (item.itemHpBonus) itemStatSpans.push(`<span class="${getStatColorClass('HP')}"><b>${item.itemHpBonus > 0 ? '+' : ''}${item.itemHpBonus}</b>HP</span>`);
                if (item.spd) itemStatSpans.push(`<span class="${getStatColorClass('SPD')}"><b>${item.spd > 0 ? '+' : ''}${item.spd}</b>SPD</span>`);
                if (item.critChance) itemStatSpans.push(`<span class="${getStatColorClass('CRIT')}"><b>+${(item.critChance * 100).toFixed(0)}</b>%CRIT</span>`);
                if (item.critDamageBonus) itemStatSpans.push(`<span class="${getStatColorClass('Crit DMG')}"><b>+${(item.critDamageBonus * 100).toFixed(0)}</b>%Crit DMG</span>`);
                if (item.lifesteal) itemStatSpans.push(`<span class="${getStatColorClass('Lifesteal')}"><b>+${(item.lifesteal * 100).toFixed(0)}</b>%Lifesteal</span>`);
                if (item.poisonOnHit) itemStatSpans.push(`<span class="${getStatColorClass('Poison on Attack')}">Poison on Attack</span>`);
                if (item.stunChance) itemStatSpans.push(`<span class="${getStatColorClass('Stun Chance')}"><b>+${(item.stunChance * 100).toFixed(0)}</b>%Stun Chance</span>`);
                if (item.reflectDamage) itemStatSpans.push(`<span class="${getStatColorClass('Reflect')}"><b>+${(item.reflectDamage * 100).toFixed(0)}</b>%Reflect</span>`);
                if (item.reflectBlockedDamage) itemStatSpans.push(`<span class="${getStatColorClass('Reflect Blocked')}">Reflect <b>${(item.reflectBlockedDamage * 100).toFixed(0)}%</b> Blocked DMG</span>`);
                if (item.dodgeChance) itemStatSpans.push(`<span class="${getStatColorClass('DODGE')}"><b>+${(item.dodgeChance * 100).toFixed(0)}</b>%DODGE</span>`);
                if (item.hpRegenPerTurn) itemStatSpans.push(`<span class="${getStatColorClass('REG')}"><b>+${item.hpRegenPerTurn}</b>REG</span>`);
                if (item.thornsDamage) itemStatSpans.push(`<span class="${getStatColorClass('THNS')}"><b>+${item.thornsDamage}</b>THNS</span>`);
                if (item.armorPenetration) itemStatSpans.push(`<span class="${getStatColorClass('PEN')}"><b>+${(item.armorPenetration * 100).toFixed(0)}</b>%PEN</span>`);
                if (item.damageReduction) itemStatSpans.push(`<span class="${getStatColorClass('DR')}"><b>-20%</b> DMG</span>`);
                if (item.doubleAttackChance === 1) itemStatSpans.push(`<span class="${getStatColorClass('DA')}">Attacks Twice</span>`);
                if (item.scaleAtkPerSpd) itemStatSpans.push(`<span class="${getStatColorClass('ATK/SPD')}"><b>+${(item.scaleAtkPerSpd * 100).toFixed(0)}</b>%ATK from SPD</span>`);
                if (item.berserkerBonus) itemStatSpans.push(`<span class="${getStatColorClass('ATK')}"><b>+${item.berserkerBonus}</b>ATK<<b>${(item.berserkerThreshold * 100).toFixed(0)}</b>%HP</span>`);
                if (item.noDodge) itemStatSpans.push(`<span class="${getStatColorClass('No DODGE')}">No DODGE</span>`);
                if (item.atkGainOnDamageTaken) itemStatSpans.push(`<span class="${getStatColorClass('ATK/Dmg Taken')}"><b>+${item.atkGainOnDamageTaken}</b>ATK/Dmg Taken</span>`);
                if (item.spdGainOnDamageTaken) itemStatSpans.push(`<span class="${getStatColorClass('SPD on DODGE')}"><b>+${item.spdGainOnDamageTaken}</b>SPD on DODGE</span>`);
                if (item.spdPerTurn) itemStatSpans.push(`<span class="${getStatColorClass('SPD/Turn')}"><b>+${item.spdPerTurn}</b>SPD/Turn</span>`);
                if (item.defDebuffPerTurn) itemStatSpans.push(`<span class="${getStatColorClass('DEF/Turn')}"><b>-${item.defDebuffPerTurn}</b>DEF/Turn</span>`);
                if (item.soulbloodThreshold) itemStatSpans.push(`<span class="${getStatColorClass('DEF if >Dmg')}"><b>+${item.soulbloodDefGain}</b>DEF on taking ><b>${item.soulbloodThreshold}</b>Dmg</span>`);
                if (item.dodgeBuffPerTurn) itemStatSpans.push(`<span class="${getStatColorClass('DODGE/Turn')}"><b>+${(item.dodgeBuffPerTurn * 100).toFixed(0)}</b>%DODGE/Turn</span>`);
                if (item.defDebuffOnHit) itemStatSpans.push(`<span class="${getStatColorClass('DEF/Hit')}"><b>-${(item.defDebuffOnHit * 100).toFixed(0)}</b>%DEF/Hit</span>`);
                if (item.atkDebuffOnHit) itemStatSpans.push(`<span class="${getStatColorClass('ATK/Hit')}"><b>-${(item.atkDebuffOnHit * 100).toFixed(0)}</b>%ATK/Hit</span>`);
                if (item.reviveThreshold) itemStatSpans.push(`<span class="${getStatColorClass('Heal HP if <HP')}">Heal <b>${item.reviveHeal}</b>HP if <<b>${item.reviveThreshold}</b>HP</span>`);
                if (item.spdFromCrit) itemStatSpans.push(`<span class="${getStatColorClass('SPD from CRIT %')}">+SPD from CRIT %</span>`);
                if (item.lowHpDamageBonus > 0) itemStatSpans.push(`<span class="${getStatColorClass('DMG <40%HP')}"><b>x${item.lowHpDamageBonus}</b> DMG <${item.lowHpThreshold*100}%HP</span>`);
                if (item.maxHpFromAtk) itemStatSpans.push(`<span class="${getStatColorClass('MAX HP=ATK')}">+Max HP equal to ATK</span>`);
                if (item.atkBasedOnMaxHp) itemStatSpans.push(`<span class="${getStatColorClass('ATK%=MAX HP')}">ATK=<b>${(item.atkBasedOnMaxHp * 100).toFixed(0)}</b>%MAX HP</span>`);
                if (item.regenOnCritOrDodge) itemStatSpans.push(`<span class="${getStatColorClass('REG on Crit/Dodge')}"><b>+${item.regenOnCritOrDodge}</b>REG on Crit/Dodge</span>`);
                if (item.critBuffOnCritOrDodge) itemStatSpans.push(`<span class="${getStatColorClass('CRIT BUFF')}"><b>+${(item.critBuffOnCritOrDodge * 100).toFixed(0)}%</b>CRIT on Crit/Dodge</span>`);
                if (item.regenPerMaxHpPercent) itemStatSpans.push(`<span class="${getStatColorClass('REG/Max HP')}">Regen <b>${(item.regenPerMaxHpPercent * 100).toFixed(0)}%</b> Max HP</span>`);
                if (item.hpBonusFromSpd) itemStatSpans.push(`<span class="${getStatColorClass('HP from SPD')}">+HP = SPD</span>`);
                if (item.immuneToThorns || item.immuneToReflect) itemStatSpans.push(`<span class="${getStatColorClass('Immune to Thorns/Reflect')}">Immune to Thorns/Reflect</span>`);
                if (item.immuneToCrits) itemStatSpans.push(`<span class="${getStatColorClass('Immune to Crits')}">Immune to Crits</span>`);
                if (item.spdDebuffOnHit) itemStatSpans.push(`<span class="${getStatColorClass('SPD Debuff')}"><b>-${item.spdDebuffOnHit}</b>SPD to Attacker</span>`);
                if (item.doubleRegen) itemStatSpans.push(`<span class="${getStatColorClass('x2 REG')}">x2 REG</span>`);
                if (item.regenFromSpd) itemStatSpans.push(`<span class="${getStatColorClass('REG equal to SPD')}">+REG equal to SPD</span>`);
                if (item.instakillOnZeroDef) itemStatSpans.push(`<span class="${getStatColorClass('Instakill 0-DEF')}">Instakill 0-DEF</span>`);
                if (item.spdFromDef) itemStatSpans.push(`<span class="${getStatColorClass('SPD equal to DEF')}">+SPD equal to DEF</span>`);
                if (item.selfPoisonOnStart) itemStatSpans.push(`<span class="${getStatColorClass('Start with 10 Poison')}">Start with ${item.selfPoisonOnStart} Poison</span>`);

                btn.innerHTML = `<b>${item.emoji} ${item.name}</b><br><span class="text-sm">${itemStatSpans.join(', ')}</span>`;

                let buttonClasses = `bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded-2xl shadow-md transition duration-200 ease-in-out transform hover:scale-105`;
                const isSelected = p1.inv.some(i => i.name === item.name) || p2.inv.some(i => i.name === item.name);
                if (isSelected) {
                    buttonClasses += ' item-selected';
                }
                btn.className = buttonClasses;
                btn.onclick = () => addItem(index);
                container.appendChild(btn);
            });
        }

        function addItem(index) {
            const selectedItem = itemsList[index];
            const itemButton = document.getElementById(`item-btn-${index}`);
            
            // Check if item is already selected by either player
            const isSelectedByP1 = p1.inv.some(item => item.name === selectedItem.name);
            const isSelectedByP2 = p2.inv.some(item => item.name === selectedItem.name);

            if (isSelectedByP1 || isSelectedByP2) {
                // If selected, remove it from the player who has it
                if (isSelectedByP1) {
                    p1.inv = p1.inv.filter(item => item.name !== selectedItem.name);
                    updateStats(p1, 1);
                    log(`${p1Name} dropped ${selectedItem.name}`);
                }
                if (isSelectedByP2) {
                    p2.inv = p2.inv.filter(item => item.name !== selectedItem.name);
                    updateStats(p2, 2);
                    log(`${p2Name} dropped ${selectedItem.name}`);
                }
                itemButton.classList.remove('item-selected');
            } else {
                // If not selected, add it to the first available player
                if (p1.inv.length < MAX_ITEMS_PER_PLAYER) {
                    p1.inv.push(selectedItem);
                    updateStats(p1, 1);
                    log(`${p1Name} picked up ${selectedItem.name}`);
                    itemButton.classList.add('item-selected');
                } else if (p2.inv.length < MAX_ITEMS_PER_PLAYER) {
                    p2.inv.push(selectedItem);
                    updateStats(p2, 2);
                    log(`${p2Name} picked up ${selectedItem.name}`);
                    itemButton.classList.add('item-selected');
                } else {
                    log('Both players have full inventories!');
                }
            }
        }

        function randomizeItems(playerNum) {
            let player = playerNum === 1 ? p1 : p2;
            let playerName = playerNum === 1 ? p1Name : p2Name;

            // First, remove this player's items from the selection state
            player.inv.forEach(item => {
                const originalIndex = itemsList.findIndex(i => i.name === item.name);
                const btn = document.getElementById(`item-btn-${originalIndex}`);
                if (btn) btn.classList.remove('item-selected');
            });

            player.inv = [];
            
            // Create a list of items not currently held by the OTHER player
            const otherPlayerInv = (playerNum === 1 ? p2 : p1).inv.map(i => i.name);
            let availableItems = itemsList.filter(item => !otherPlayerInv.includes(item.name));
            
            let shuffledItems = availableItems.sort(() => 0.5 - Math.random());

            for (let i = 0; i < MAX_ITEMS_PER_PLAYER; i++) {
                if (shuffledItems.length > 0) {
                    const item = shuffledItems.shift();
                    player.inv.push(item);
                    const originalIndex = itemsList.findIndex(i => i.name === item.name);
                    const btn = document.getElementById(`item-btn-${originalIndex}`);
                    if (btn) btn.classList.add('item-selected');
                }
            }
            updateStats(player, playerNum);
            log(`${playerName} randomized items: ${player.inv.map(i => i.name).join(', ')}`);
        }

        function log(message) {
            const logDiv = document.getElementById('log');
            let colorClass = 'dark:text-gray-300';

            if (message.includes('regens') || message.includes('heals')) colorClass = 'text-green-700 dark:text-green-400';
            else if (message.includes('attacks')) colorClass = 'text-red-700 dark:text-red-400';
            else if (message.includes('Critical Hit!')) colorClass = 'text-orange-600 dark:text-orange-400 font-bold';
            else if (message.includes('gains') || message.includes('reduces') || message.includes('loses')) colorClass = 'text-blue-700 dark:text-blue-400';
            else if (message.includes('poisoned') || message.includes('poison damage')) colorClass = 'text-purple-700 dark:text-purple-400';
            else if (message.includes('dodges')) colorClass = 'text-gray-500 dark:text-gray-400';
            else if (message.includes('lifesteals')) colorClass = 'text-red-500 dark:text-red-400';
            else if (message.includes('stunned')) colorClass = 'text-cyan-700 dark:text-cyan-400';
            
            const boldedMessage = message.replace(/\b(regens|attacks|poisoned|poison damage|dodges|lifesteals|heals|stunned)\b/g, '<b>$1</b>');

            logDiv.innerHTML += `<p class="mb-1 ${colorClass}">${boldedMessage}</p>`;
            fullBattleLogContent += `${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function animateHit(fighterId) {
            const el = document.getElementById(fighterId);
            el.classList.add('hit');
            setTimeout(() => el.classList.remove('hit'), 500);
        }

        const DEF_DAMAGE_BLOCK_PERCENTAGE = 0.8;

        function startBattle() {
            window.scrollTo(0, 0);

            document.querySelectorAll('#items button').forEach(btn => btn.disabled = true);
            document.getElementById('startButton').disabled = true;
            document.getElementById('randomize1').style.display = 'none';
            document.getElementById('randomize2').style.display = 'none';
            document.getElementById('presets1').style.display = 'none';
            document.getElementById('presets2').style.display = 'none';
            document.getElementById('analyzeBattleButton').style.display = 'none';
            document.getElementById('battleAnalysis').style.display = 'none';

            log('<p class="text-xl font-bold text-center text-gray-800 dark:text-gray-100 my-2">âš”ï¸ Battle Start! âš”ï¸</p>');
            fullBattleLogContent = "";

            // Finalize stats before cloning for battle
            updateStats(p1, 1);
            updateStats(p2, 2);

            battleP1 = JSON.parse(JSON.stringify(p1));
            battleP2 = JSON.parse(JSON.stringify(p2));

            // Apply start-of-battle effects
            [battleP1, battleP2].forEach((player, index) => {
                const playerName = index === 0 ? p1Name : p2Name;
                if (player.selfPoisonOnStart > 0) {
                    player.poisoned.push({damage: player.selfPoisonOnStart, turns: 9999});
                    log(`${playerName} is poisoned by Venom Stim! ðŸ’‰`);
                }
            });
            updateStats(battleP1, 1, true);
            updateStats(battleP2, 2, true);
            
            battleInterval = setInterval(async () => {
                turnCounter++;
                log(`--- Turn ${turnCounter}/${TURN_LIMIT} ---`);

                // Pre-turn effects (regen, poison, etc.)
                for (const [playerObj, playerNum] of [[battleP1, 1], [battleP2, 2]]) {
                    const currentPlayerName = (playerNum === 1 ? p1Name : p2Name);
                    const fighterId = `fighter${playerNum}`;

                    // Apply turn-based stat changes
                    if (playerObj.spdPerTurn > 0) {
                        playerObj.currentSpd += playerObj.spdPerTurn;
                        log(`${currentPlayerName} gains ${playerObj.spdPerTurn} SPD from Winged Tabis! Current SPD: ${Math.round(playerObj.currentSpd)} ðŸ‘Ÿ`);
                        highlightStat(`spd${playerNum}`, 'increase');
                    }
                    if (playerObj.defDebuffPerTurn > 0) {
                        playerObj.currentDef = Math.max(0, playerObj.currentDef - playerObj.defDebuffPerTurn);
                        log(`${currentPlayerName} <b>loses</b> ${playerObj.defDebuffPerTurn} DEF from Cursed Rune. Current DEF: ${Math.round(playerObj.currentDef)} â˜ ï¸`);
                        highlightStat(`def${playerNum}`, 'decrease');
                    }
                    if (playerObj.dodgeBuffPerTurn > 0) {
                        playerObj.currentDodgeChance = Math.min(1, playerObj.currentDodgeChance + playerObj.dodgeBuffPerTurn);
                        log(`${currentPlayerName} <b>gains</b> ${(playerObj.dodgeBuffPerTurn * 100).toFixed(0)}% DODGE from Foresight Orb. Current DODGE: ${(playerObj.currentDodgeChance * 100).toFixed(0)}% ðŸ”®`);
                    }

                    // Regen
                    let regenAmount = playerObj.hpRegenPerTurn;
                    if (playerObj.regenFromSpd) {
                        regenAmount += playerObj.currentSpd;
                    }
                    if (playerObj.regenPerCurrentHpPercent > 0) {
                        regenAmount += Math.round(playerObj.currentHp * playerObj.regenPerCurrentHpPercent);
                    }
                    if (playerObj.regenPerMaxHpPercent > 0) {
                        regenAmount += Math.round(playerObj.maxHp * playerObj.regenPerMaxHpPercent);
                    }
                    if (playerObj.doubleRegen) {
                        regenAmount *= 2;
                    }

                    if (regenAmount > 0) {
                        playerObj.currentHp = Math.min(playerObj.maxHp, playerObj.currentHp + regenAmount);
                        log(`${currentPlayerName} <b>regens</b> ${Math.round(regenAmount)} HP. Current HP: ${Math.round(playerObj.currentHp)} â¤ï¸`);
                        showFloatingText(fighterId, regenAmount, 'heal');
                    }

                    // Poison
                    if (playerObj.poisoned.length > 0) {
                        await sleep(500); // Delay before poison damage
                        let totalPoisonDmg = playerObj.poisoned.reduce((sum, poison) => sum + poison.damage, 0);
                        playerObj.currentHp -= totalPoisonDmg;
                        log(`${currentPlayerName} takes ${totalPoisonDmg} poison damage. Current HP: ${Math.round(playerObj.currentHp)} â˜ ï¸`);
                        showFloatingText(fighterId, totalPoisonDmg, 'poison');
                    }
                    
                    // Update UI after all start-of-turn effects
                    updateStats(playerObj, playerNum, true);
                }

                if (checkBattleEnd()) return;

                // Main attack phase
                const turnOrder = battleP1.currentSpd >= battleP2.currentSpd ? [[battleP1, battleP2, 1, 2], [battleP2, battleP1, 2, 1]] : [[battleP2, battleP1, 2, 1], [battleP1, battleP2, 1, 2]];

                for (const [attacker, defender, attNum, defNum] of turnOrder) {
                    if (checkBattleEnd()) return;
                    if (attacker.stunnedTurns > 0) {
                        log(`${(attNum === 1 ? p1Name : p2Name)} is stunned and skips an attack! ðŸ˜´`);
                        const fighterEl = document.getElementById(`fighter${attNum}`);
                        fighterEl.classList.add('stun-flash');
                        setTimeout(() => fighterEl.classList.remove('stun-flash'), 300);
                        attacker.stunnedTurns--;
                    } else {
                        await executeAttack(attacker, defender, attNum, defNum);
                    }
                    await sleep(500); // Small delay between players' turns
                }

                if (checkBattleEnd()) return;

                // Speed-based extra attack phase
                const speedDiff = battleP1.currentSpd - battleP2.currentSpd;
                if (speedDiff >= 10) {
                    log(`${p1Name} gets an extra attack due to speed!`);
                    await sleep(500);
                    if (!checkBattleEnd() && battleP1.stunnedTurns <= 0) {
                        await executeAttack(battleP1, battleP2, 1, 2);
                    }
                } else if (speedDiff <= -10) {
                    log(`${p2Name} gets an extra attack due to speed!`);
                    await sleep(500);
                    if (!checkBattleEnd() && battleP2.stunnedTurns <= 0) {
                        await executeAttack(battleP2, battleP1, 2, 1);
                    }
                }

                checkBattleEnd();

            }, 2500); // Slower turn interval for clarity
        }

        function checkBattleEnd() {
            let battleEnded = false;
            let winnerMessage = '';

            if (battleP1.currentHp <= 0 || battleP2.currentHp <= 0) {
                if (battleP1.currentHp <= 0) {
                    battleP1.currentHp = 0; // Clamp HP at 0
                    document.getElementById('fighter1').classList.add('loser-tint');
                }
                if (battleP2.currentHp <= 0) {
                    battleP2.currentHp = 0; // Clamp HP at 0
                    document.getElementById('fighter2').classList.add('loser-tint');
                }
                updateStats(battleP1, 1, true);
                updateStats(battleP2, 2, true);

                const winnerNum = battleP1.currentHp <= 0 ? 2 : 1;
                winnerMessage = `<p class="text-2xl font-bold text-center text-green-700 dark:text-green-400 my-2">ðŸ† ${ (winnerNum === 1 ? p1Name : p2Name) } Wins! ðŸ†</p>`;
                battleEnded = true;
            } else if (turnCounter >= TURN_LIMIT) {
                if (battleP1.currentHp > battleP2.currentHp) {
                    winnerMessage = `<p class="text-2xl font-bold text-center text-green-700 dark:text-green-400 my-2">ðŸŽ‰ ${p1Name} Wins by HP Advantage! ðŸŽ‰</p>`;
                } else if (battleP2.currentHp > battleP1.currentHp) {
                    winnerMessage = `<p class="text-2xl font-bold text-center text-green-700 dark:text-green-400 my-2">ðŸŽ‰ ${p2Name} Wins by HP Advantage! ðŸŽ‰</p>`;
                } else {
                    winnerMessage = `<p class="text-2xl font-bold text-center text-gray-700 dark:text-gray-200 my-2">ðŸ¤ It's a Draw after ${TURN_LIMIT} turns! ðŸ¤</p>`;
                }
                battleEnded = true;
            }

            if (battleEnded) {
                log(winnerMessage);
                clearInterval(battleInterval);
                document.getElementById('analyzeBattleButton').style.display = 'inline-block';
            }
            return battleEnded;
        }

        async function executeAttack(attacker, defender, attNum, defNum, isDoubleAttack = false) {
            const attackerName = (attNum === 1 ? p1Name : p2Name);
            const defenderName = (defNum === 1 ? p1Name : p2Name);
            const defenderFighterId = `fighter${defNum}`;
            const attackerFighterId = `fighter${attNum}`;

            // Instakill check
            if (attacker.instakillOnZeroDef && defender.currentDef <= 0) {
                log(`${attackerName}'s Hidden Dagger finds a fatal opening! ${defenderName} is instantly defeated! â˜ ï¸`);
                defender.currentHp = 0;
                updateStats(defender, defNum, true);
                checkBattleEnd();
                return;
            }

            // Dodge check
            if (Math.random() < defender.currentDodgeChance && !attacker.noDodgeAttack && !defender.noDodge) {
                log(`${defenderName} dodges the attack! ðŸ’¨`);
                const fighterEl = document.getElementById(defenderFighterId);
                fighterEl.classList.add('dodge-flash');
                setTimeout(() => fighterEl.classList.remove('dodge-flash'), 300);
                animateHit(defenderFighterId);
                if (defender.spdGainOnDamageTaken > 0) {
                    defender.currentSpd += defender.spdGainOnDamageTaken;
                    log(`${defenderName} gains ${defender.spdGainOnDamageTaken} SPD on DODGE! Current SPD: ${Math.round(defender.currentSpd)} ðŸƒâ€â™‚ï¸`);
                    highlightStat(`spd${defNum}`, 'increase');
                }
                if (defender.regenOnCritOrDodge > 0) {
                    defender.currentHp = Math.min(defender.maxHp, defender.currentHp + defender.regenOnCritOrDodge);
                    log(`${defenderName} <b>regens</b> ${defender.regenOnCritOrDodge} HP on DODGE!`);
                    showFloatingText(defenderFighterId, defender.regenOnCritOrDodge, 'heal');
                }
                if (defender.critBuffOnCritOrDodge > 0) {
                    defender.currentCritChance = Math.min(1, defender.currentCritChance + defender.critBuffOnCritOrDodge);
                    log(`${defenderName} gains ${(defender.critBuffOnCritOrDodge * 100).toFixed(0)}% CRIT from Mystic Band on DODGE! âœ¨`);
                }
                updateStats(defender, defNum, true);
                return;
            }

            let calculatedAttackerAtk = attacker.currentAtk;
            if (attacker.berserkerBonus > 0 && attacker.currentHp <= attacker.maxHp * attacker.berserkerThreshold) {
                calculatedAttackerAtk += attacker.berserkerBonus;
                log(`${attackerName} activates Berserker Helm bonus!`);
            }

            let effectiveDefenderDef = defender.currentDef * (1 - attacker.armorPenetration);
            let blockedDamage = effectiveDefenderDef * DEF_DAMAGE_BLOCK_PERCENTAGE;
            let rawDamage = Math.max(0, calculatedAttackerAtk - blockedDamage);

            if (attacker.lowHpDamageBonus > 0 && defender.currentHp < defender.maxHp * attacker.lowHpThreshold) {
                rawDamage *= attacker.lowHpDamageBonus;
                log(`${attackerName}'s Assassin's Cloak deals double damage to a weakened target!`);
            }

            let isCritical = false;
            let floatingTextClass = 'damage';
            if (Math.random() < attacker.currentCritChance && !defender.immuneToCrits) {
                rawDamage *= (2 + attacker.critDamageBonus);
                isCritical = true;
                log(`Critical Hit! ðŸ’¥`);
                floatingTextClass = 'critical';
                if (attacker.regenOnCritOrDodge > 0) {
                    attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + attacker.regenOnCritOrDodge);
                    log(`${attackerName} <b>regens</b> ${attacker.regenOnCritOrDodge} HP from on CRIT!`);
                    showFloatingText(attackerFighterId, attacker.regenOnCritOrDodge, 'heal');
                }
                if (attacker.critBuffOnCritOrDodge > 0) {
                    attacker.currentCritChance = Math.min(1, attacker.currentCritChance + attacker.critBuffOnCritOrDodge);
                    log(`${attackerName} gains ${(attacker.critBuffOnCritOrDodge * 100).toFixed(0)}% CRIT from Mystic Band on CRIT! âœ¨`);
                }
            } else if (defender.immuneToCrits && Math.random() < attacker.currentCritChance) {
                log(`${defenderName} is immune to the critical hit!`);
            }

            rawDamage *= (1 - defender.damageReduction);
            let finalDamage = Math.round(Math.max(1, rawDamage));

            defender.currentHp -= finalDamage;
            log(`${attackerName} attacks ${defenderName} for <span class="font-bold text-red-700 dark:text-red-400">${finalDamage}</span> damage${isCritical ? ' (CRIT!)' : ''} ðŸ’¥`);
            animateHit(defenderFighterId);
            showFloatingText(defenderFighterId, finalDamage, floatingTextClass);

            // Revival Charm logic
            if (defender.reviveThreshold > 0 && !defender.hasRevived && defender.currentHp > 0 && defender.currentHp <= defender.reviveThreshold) {
                const healAmount = defender.reviveHeal;
                defender.currentHp = Math.min(defender.maxHp, defender.currentHp + healAmount);
                defender.hasRevived = true;
                log(`${defenderName} is saved by Revival Charm and heals for ${healAmount} HP! ðŸ’—`);
                showFloatingText(defenderFighterId, healAmount, 'heal');
            }
            
            updateStats(defender, defNum, true);

            if (finalDamage > 0) {
                // Soulblood Ampule logic
                if (defender.soulbloodThreshold > 0 && finalDamage > defender.soulbloodThreshold) {
                    defender.currentDef += defender.soulbloodDefGain;
                    log(`${defenderName} gains ${defender.soulbloodDefGain} DEF from Soulblood Ampule!`);
                    highlightStat(`def${defNum}`, 'increase');
                }
                // Other Post-hit effects
                if (defender.spdDebuffOnHit > 0) {
                    attacker.currentSpd -= defender.spdDebuffOnHit;
                    log(`${defenderName}'s Ice Bulwark chills ${attackerName}, reducing SPD by ${defender.spdDebuffOnHit}! ðŸ§Š`);
                    highlightStat(`spd${attNum}`, 'decrease');
                }
                
                if (defender.atkGainOnDamageTaken > 0) {
                    defender.currentAtk += defender.atkGainOnDamageTaken;
                    log(`${defenderName} gains ${defender.atkGainOnDamageTaken} ATK!`);
                    highlightStat(`atk${defNum}`, 'increase');
                }
                if (attacker.lifesteal > 0) {
                    let lifestealAmount = Math.round(finalDamage * attacker.lifesteal);
                    attacker.currentHp = Math.min(attacker.maxHp, attacker.currentHp + lifestealAmount);
                    log(`${attackerName} lifesteals ${lifestealAmount} HP. ðŸ©¸`);
                    showFloatingText(attackerFighterId, lifestealAmount, 'heal');
                }
                
                updateStats(attacker, attNum, true);
                updateStats(defender, defNum, true);
                
                if (checkBattleEnd()) return;

                // Delayed effects
                if (defender.thornsDamage > 0 && !attacker.immuneToThorns) {
                    await sleep(500);
                    attacker.currentHp -= defender.thornsDamage;
                    log(`${attackerName} takes ${defender.thornsDamage} thorns damage. ðŸŒµ`);
                    showFloatingText(attackerFighterId, defender.thornsDamage, 'thorns');
                    updateStats(attacker, attNum, true);
                    if (checkBattleEnd()) return;
                }
                if (defender.reflectBlockedDamage > 0 && !attacker.immuneToReflect) {
                    await sleep(500);
                    let reflectedDmg = Math.round(blockedDamage * defender.reflectBlockedDamage);
                    if (reflectedDmg > 0) {
                        attacker.currentHp -= reflectedDmg;
                        log(`${attackerName} takes ${reflectedDmg} reflected damage. ðŸªž`);
                        showFloatingText(attackerFighterId, reflectedDmg, 'thorns');
                        updateStats(attacker, attNum, true);
                        if (checkBattleEnd()) return;
                    }
                }
                
                // Status effects
                if (attacker.poisonOnHit) {
                    defender.poisoned.push({damage: attacker.poisonDmgPerTurn, turns: attacker.poisonTurns || 9999});
                    log(`${defenderName} is poisoned! ðŸ¤¢`);
                }
                if (attacker.stunChance > 0 && Math.random() < attacker.stunChance) {
                    defender.stunnedTurns = 1;
                    log(`${defenderName} is stunned! âš¡`);
                }
                if (attacker.defDebuffOnHit > 0) {
                    defender.currentDef = Math.max(0, defender.currentDef * (1 - attacker.defDebuffOnHit));
                    log(`${attackerName} reduces ${defenderName}'s DEF! ðŸƒ`);
                    highlightStat(`def${defNum}`, 'decrease');
                }
                if (defender.atkDebuffOnHit > 0) {
                    attacker.currentAtk = Math.max(0, attacker.currentAtk * (1 - defender.atkDebuffOnHit));
                    log(`${defenderName} reduces ${attackerName}'s ATK! â„ï¸`);
                    highlightStat(`atk${attNum}`, 'decrease');
                }
            }
            
            updateStats(attacker, attNum, true);
            updateStats(defender, defNum, true);

            // Double Attack Logic with Delay
            if (!isDoubleAttack && attacker.doubleAttackChance > 0 && Math.random() < attacker.doubleAttackChance) {
                if (defender.currentHp > 0 && attacker.currentHp > 0) {
                    log(`${attackerName} strikes again!`);
                    await sleep(500); // Add delay here
                    await executeAttack(attacker, defender, attNum, defNum, true);
                }
            }
        }

        function resetGame() {
            clearInterval(battleInterval);
            turnCounter = 0;
            log('<p class="text-xl font-bold text-center text-gray-800 dark:text-gray-100 my-2">ðŸ”„ Game Reset! ðŸ”„</p>');
            document.getElementById('log').innerHTML = '<p class="text-gray-500 italic">Battle log will appear here...</p>';
            document.getElementById('battleAnalysis').innerHTML = '<p class="text-emerald-700 italic">Battle analysis will appear here...</p>';
            document.getElementById('battleAnalysis').style.display = 'none';

            initializePlayers();
            renderItems(); // Re-render to clear selections
            updateStats(p1, 1);
            updateStats(p2, 2);

            document.getElementById('fighter1').classList.remove('loser-tint', 'poison-tint');
            document.getElementById('fighter2').classList.remove('loser-tint', 'poison-tint');

            document.querySelectorAll('#items button').forEach(btn => btn.disabled = false);
            document.getElementById('startButton').disabled = false;
            document.getElementById('randomize1').style.display = 'inline-block';
            document.getElementById('randomize2').style.display = 'inline-block';
            document.getElementById('presets1').style.display = 'inline-block';
            document.getElementById('presets2').style.display = 'inline-block';
            document.getElementById('analyzeBattleButton').style.display = 'none';
        }

        async function analyzeBattle() {
            const analyzeButton = document.getElementById('analyzeBattleButton');
            const analysisLog = document.getElementById('battleAnalysis');

            analyzeButton.disabled = true;
            analysisLog.style.display = 'block';
            analysisLog.innerHTML = '<p class="text-emerald-700 italic">Analyzing battle... Please wait. âœ¨</p>';

            const prompt = `Analyze this auto-battler fight. Identify winner and their decisive strategy (stats, item synergies). Detail which items were most/least impactful. Suggest one counter-build for the winner. Keep analysis concise (max 70 words). Battle Log: ${fullBattleLogContent}`;


            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            const apiKey = ""; // Canvas will provide this at runtime
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const analysisText = result.candidates[0].content.parts[0].text;
                    analysisLog.innerHTML = `<p class="text-emerald-700 font-semibold">${analysisText}</p>`;
                } else {
                    analysisLog.innerHTML = `<p class="text-emerald-700 italic">Analysis unavailable.</p>`;
                }
            } catch (error) {
                console.error("Error fetching battle analysis:", error);
                analysisLog.innerHTML = `<p class="text-emerald-700 italic">Failed to analyze battle. Please try again.</p>`;
            } finally {
                analyzeButton.disabled = false;
            }
        }
        
        // Make functions globally accessible
        window.openPresetsModal = openPresetsModal;
        window.randomizeItems = randomizeItems;
        window.startBattle = startBattle;
        window.resetGame = resetGame;
        window.analyzeBattle = analyzeBattle;

        initializePlayers();
        renderItems();
        updateStats(p1, 1);
        updateStats(p2, 2);
    </script>
</body>
</html>
